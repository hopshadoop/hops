<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="testConf.xsl"?>
<!--
   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
-->
<configuration>
  <!-- Normal mode is test. To run just the commands and dump the output
       to the log, set it to nocompare -->
  <mode>test</mode>
  
  <!--  Comparator types:
           ExactComparator
           SubstringComparator
           RegexpComparator
           TokenComparator
           -->
  <tests>
    <!-- Tests for help -->
    <test> <!-- TESTED -->
      <description>help: check if fs help message is shown</description>
      <test-commands>
        <command>-help</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>SubstringComparator</type>
          <expected-output>Usage: hadoop fs [generic options]</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for ls</description>
      <test-commands>
        <command>-help ls</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-ls \[-C\] \[-d\] \[-h\] \[-q\] \[-R\] \[-t\] \[-S\] \[-r\] \[-u\] \[-e\] \[&lt;path&gt; \.\.\.\] :( |\t)*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*List the contents that match the specified file pattern. If path is not</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*specified, the contents of /user/&lt;currentUser&gt; will be listed. For a directory a( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*list of its direct children is returned \(unless -d option is specified\).*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*Directory entries are of the form:( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*permissions - userId groupId sizeOfDirectory\(in bytes\)( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*modificationDate\(yyyy-MM-dd HH:mm\) directoryName( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*and file entries are of the form:( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*permissions numberOfReplicas userId groupId sizeOfFile\(in bytes\)( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*modificationDate\(yyyy-MM-dd HH:mm\) fileName( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*-C\s+Display the paths of files and directories only\.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*-d\s+Directories are listed as plain files\.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*-h\s+Formats the sizes of files in a human-readable fashion( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*rather than a number of bytes\.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*-q\s+Print \? instead of non-printable characters\.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*-R\s+Recursively list the contents of directories\.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*-t\s+Sort files by modification time \(most recent first\)\.</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*-S\s+Sort files by size\.</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*-r\s+Reverse the order of the sort\.</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*-u\s+Use time of last access instead of modification for</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*display and sorting\.</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*-e\s+Display the erasure coding policy of files and directories\.</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for lsr</description>
      <test-commands>
        <command>-help lsr</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-lsr :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s+\(DEPRECATED\) Same as 'ls -R'</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for get</description>
      <test-commands>
        <command>-help get</command>
      </test-commands>
      <cleanup-commands>
        <!-- No cleanup -->
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-get( )*\[-f\]( )*\[-p\]( )*\[-ignoreCrc\]( )*\[-crc\]( )*&lt;src&gt; \.\.\. &lt;localdst&gt; :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>\s*Copy files that match the file pattern &lt;src&gt; to the local name.  &lt;src&gt; is kept.\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
           <expected-output>^( |\t)*When copying multiple files, the destination must be a directory. Passing -f( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*overwrites the destination if it already exists and -p preserves access and( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
         <expected-output>^( |\t)*modification times, ownership and the mode.*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for du</description>
      <test-commands>
        <command>-help du</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-du \[-s\] \[-h\] \[-v\] \[-x\] &lt;path&gt; \.\.\. :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Show the amount of space, in bytes, used by the files that match the specified\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*file pattern. The following flags are optional:\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*-s\s*Rather than showing the size of each individual file that matches the\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*pattern, shows the total \(summary\) size.\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*-h\s*Formats the sizes of files in a human-readable fashion rather than a number\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>\s*of bytes.\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*-x\s*Excludes snapshots from being counted.\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Note that, even without the -s option, this only shows size summaries one level\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*deep into a directory.</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*The output is in the form </expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*size\s+disk space consumed\s+name\(full path\)\s*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for dus</description>
      <test-commands>
        <command>-help dus</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-dus :</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*\(DEPRECATED\) Same as 'du -s'</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for count</description>
      <test-commands>
        <command>-help count</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-count \[-q\] \[-h\] \[-v\] \[-t \[&lt;storage type&gt;\]\] \[-u\] \[-x\] \[-e\] &lt;path&gt; \.\.\. :( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Count the number of directories, files and bytes under the paths( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*that match the specified file pattern.  The output columns are:( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*DIR_COUNT FILE_COUNT CONTENT_SIZE PATHNAME( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*or, with the -q option:( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*QUOTA REM_QUOTA SPACE_QUOTA REM_SPACE_QUOTA( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*DIR_COUNT FILE_COUNT CONTENT_SIZE PATHNAME( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*The -h option shows file sizes in human readable format.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*The -v option displays a header line.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*The -x option excludes snapshots from being calculated.( )*</expected-output>
        </comparator>
      </comparators>
    </test>

   <test> <!-- TESTED -->
      <description>help: help for mv</description>
      <test-commands>
        <command>-help mv</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-mv &lt;src&gt; \.\.\. &lt;dst&gt; :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>\s*Move files that match the specified file pattern &lt;src&gt; to a destination &lt;dst&gt;.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*When moving multiple files, the destination must be a directory.( )*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for cp</description>
      <test-commands>
        <command>-help cp</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-cp \[-f\] \[-p \| -p\[topax\]\] \[-d\] &lt;src&gt; \.\.\. &lt;dst&gt; :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Copy files that match the file pattern &lt;src&gt; to a destination.  When copying( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*multiple files, the destination must be a directory.( )*Passing -p preserves status( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*\[topax\] \(timestamps, ownership, permission, ACLs, XAttr\). If -p is specified( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*with no &lt;arg&gt;, then preserves timestamps, ownership, permission. If -pa is( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*specified, then preserves permission also because ACL is a super-set of( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*permission. Passing -f overwrites the destination if it already exists. raw( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*namespace extended attributes are preserved if \(1\) they are supported \(HDFS( )*</expected-output>
        </comparator>
        <comparator>
            <type>RegexpComparator</type>
            <expected-output>^( |\t)*only\) and, \(2\) all of the source and target pathnames are in the \/\.reserved\/raw( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*hierarchy. raw namespace xattr preservation is determined solely by the presence( )*</expected-output>
        </comparator>
        <comparator>
            <type>RegexpComparator</type>
          <expected-output>^\s*\(or absence\) of the \/\.reserved\/raw prefix and not by the -p option\. Passing -d( )*</expected-output>
        </comparator>
        <comparator>
            <type>RegexpComparator</type>
            <expected-output>^\s*will skip creation of temporary file\(&lt;dst&gt;\._COPYING_\)\.( )*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for rm</description>
      <test-commands>
        <command>-help rm</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-rm \[-f\] \[-r\|-R\] \[-skipTrash\] \[-safely\] &lt;src&gt; \.\.\. :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Delete all files that match the specified file pattern. Equivalent to the Unix( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*command "rm &lt;src&gt;"( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*-skipTrash\s+option bypasses trash, if enabled, and immediately deletes &lt;src&gt;\.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s+-f\s+If the file does not exist, do not display a diagnostic message or\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s+modify the exit status to reflect an error\.\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s+-\[rR\]\s+Recursively deletes directories\.\s*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for rmdir</description>
      <test-commands>
        <command>-help rmdir</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-rmdir \[--ignore-fail-on-non-empty\] &lt;dir&gt; \.\.\. :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>\s+Removes the directory entry specified by each directory argument, provided it is\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>\s+empty\.\s*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for rmr</description>
      <test-commands>
        <command>-help rmr</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-rmr :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*\(DEPRECATED\) Same as '-rm -r'\s*</expected-output>
        </comparator>
      </comparators>
    </test>

   <test> <!-- TESTED -->
      <description>help: help for put</description>
      <test-commands>
        <command>-help put</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-put \[-f\] \[-p\] \[-l\] \[-d\] \[-t &lt;thread count&gt;\] &lt;localsrc&gt; \.\.\. &lt;dst&gt; :( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Copy files from the local file system into fs.( )*Copying fails if the file already( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*exists, unless the -f flag is given.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Flags:( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*-p                 Preserves access and modification times, ownership and the( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*mode.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*-f                 Overwrites the destination if it already exists.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*-t &lt;thread count&gt;  Number of threads to be used, default is 1.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*-l                 Allow DataNode to lazily persist the file to disk. Forces( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*replication factor of 1. This flag will result in reduced( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*durability. Use with care.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*-d                 Skip creation of temporary file\(&lt;dst&gt;\._COPYING_\).( )*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for copyFromLocal</description>
      <test-commands>
        <command>-help copyFromLocal</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-copyFromLocal \[-f\] \[-p\] \[-l\] \[-d\] \[-t &lt;thread count&gt;\] &lt;localsrc&gt; \.\.\. &lt;dst&gt; :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Copy files from the local file system into fs.( )*Copying fails if the file already( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*exists, unless the -f flag is given.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Flags:( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*-p                 Preserves access and modification times, ownership and the( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*mode.( )*</expected-output>
        </comparator>
        <comparator>
           <type>RegexpComparator</type>
           <expected-output>^\s*-f                 Overwrites the destination if it already exists.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*-t &lt;thread count&gt;  Number of threads to be used, default is 1.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*-l                 Allow DataNode to lazily persist the file to disk. Forces( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*replication factor of 1. This flag will result in reduced( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*durability. Use with care.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*-d                 Skip creation of temporary file\(&lt;dst&gt;\._COPYING_\).( )*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for moveFromLocal</description>
      <test-commands>
        <command>-help moveFromLocal</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-moveFromLocal &lt;localsrc&gt; \.\.\. &lt;dst&gt; :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*Same as -put, except that the source is deleted after it's copied.</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for get</description>
      <test-commands>
        <command>-help get</command>
      </test-commands>
      <cleanup-commands>
        <!-- No cleanup -->
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-get( )*\[-f\]( )*\[-p\]( )*\[-ignoreCrc\]( )*\[-crc\]( )*&lt;src&gt; \.\.\. &lt;localdst&gt; :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*Copy files that match the file pattern &lt;src&gt; to the local name.( )*&lt;src&gt; is kept.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*When copying multiple files, the destination must be a directory. Passing -f( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*overwrites the destination if it already exists and -p preserves access and( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
         <expected-output>^( |\t)*modification times, ownership and the mode.*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for getmerge</description>
      <test-commands>
        <command>-help getmerge</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-getmerge \[-nl\] \[-skip-empty-file\] &lt;src&gt; &lt;localdst&gt; :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*Get all the files in the directories that match the source file pattern and( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*merge and sort them to only one file on local fs. &lt;src&gt; is kept.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*-nl\s+Add a newline character at the end of each file.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*-skip-empty-file\s+Do not add new line character for empty file.( )*</expected-output>
        </comparator>

      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for cat</description>
      <test-commands>
        <command>-help cat</command>
      </test-commands>
      <cleanup-commands>
        <!-- No cleanup -->
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-cat \[-ignoreCrc\] &lt;src&gt; \.\.\. :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Fetch all files that match the file pattern &lt;src&gt; and display their content on\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*stdout.</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for checksum</description>
      <test-commands>
        <command>-help checksum</command>
      </test-commands>
      <cleanup-commands>
        <!-- No cleanup -->
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-checksum &lt;src&gt; \.\.\. :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Dump checksum information for files that match the file pattern &lt;src&gt; to stdout\.\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Note that this requires a round-trip to a datanode storing each block of the\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*file, and thus is not efficient to run on a large number of files\. The checksum\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*of a file depends on its content, block size and the checksum algorithm and\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*parameters used for creating the file\.\s*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for copyToLocal</description>
      <test-commands>
        <command>-help copyToLocal</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-copyToLocal \[-f\] \[-p\] \[-ignoreCrc\] \[-crc\] &lt;src&gt; \.\.\. &lt;localdst&gt; :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Identical to the -get command.\s*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for moveToLocal</description>
      <test-commands>
        <command>-help moveToLocal</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-moveToLocal &lt;src&gt; &lt;localdst&gt; :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Not implemented yet</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for mkdir</description>
      <test-commands>
        <command>-help mkdir</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-mkdir \[-p\] &lt;path&gt; \.\.\. :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Create a directory in specified location.( )*</expected-output>
        </comparator>
        <comparator>
          <type>TokenComparator</type>
          <expected-output>-p  Do not fail if the directory already exists</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for setrep</description>
      <test-commands>
        <command>-help setrep</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-setrep \[-R\] \[-w\] &lt;rep&gt; &lt;path&gt; \.\.\. :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Set the replication level of a file. If &lt;path&gt; is a directory then the command( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*recursively changes the replication factor of all files under the directory tree( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*rooted at &lt;path&gt;\. The EC files will be ignored here\.( )*</expected-output>
        </comparator>
        <comparator>
            <type>RegexpComparator</type>
            <expected-output>^\s*-w\s+It requests that the command waits for the replication to complete\. This( )*</expected-output>
        </comparator>
        <comparator>
            <type>RegexpComparator</type>
            <expected-output>^( |\t)*can potentially take a very long time\.( )*</expected-output>
        </comparator>
          <comparator>
              <type>RegexpComparator</type>
              <expected-output>^( |\t)*-R\s+It is accepted for backwards compatibility\. It has no effect\.( )*</expected-output>
          </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for touch</description>
      <test-commands>
        <command>-help touch</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-touch \[-a\] \[-m\] \[-t TIMESTAMP \] \[-c\] &lt;path&gt; \.\.\. :( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Updates the access and modification times of the file specified by the &lt;path&gt; to( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*the current time. If the file does not exist, then a zero length file is created( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*at &lt;path&gt; with current time as the timestamp of that &lt;path&gt;.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*-a\s+Change only the access time( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*-a\s+Change only the access time( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*-m\s+Change only the modification time( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*-t\s+TIMESTAMP\s+Use specified timestamp \(in format yyyyMMddHHmmss\) instead of</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*current time( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*-c\s+Do not create any files( )*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for touchz</description>
      <test-commands>
        <command>-help touchz</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-touchz &lt;path&gt; \.\.\. :( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*Creates a file of zero length at &lt;path&gt; with current time as the timestamp of( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)* that &lt;path&gt;\. An error is returned if the file exists with non-zero length( )*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for test</description>
      <test-commands>
        <command>-help test</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-test -\[defsz\] &lt;path&gt; :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Answer various questions about &lt;path&gt;, with result via exit status.</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*-[defsz]\s+return 0 if .*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for stat</description>
      <test-commands>
        <command>-help stat</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-stat \[format\] &lt;path&gt; \.\.\. :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*Print statistics about the file/directory at &lt;path&gt;( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*in the specified format. Format accepts permissions in( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*octal \(%a\) and symbolic \(%A\), filesize in( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*bytes \(%b\), type \(%F\), group name of owner \(%g\),( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*name \(%n\), block size \(%o\), replication \(%r\), user name( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*of owner \(%u\), access date \(%x, %X\).( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*modification date \(%y, %Y\).( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*%x and %y show UTC date as "yyyy-MM-dd HH:mm:ss" and( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*%X and %Y show milliseconds since January 1, 1970 UTC.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*If the format is not specified, %y is used by default.( )*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for tail</description>
      <test-commands>
        <command>-help tail</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-tail \[-f\] &lt;file&gt; :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Show the last 1KB of the file.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*-f\s+Shows appended data as the file grows.( )*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for chmod</description>
      <test-commands>
        <command>-help chmod</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-chmod \[-R\] &lt;MODE\[,MODE\]... \| OCTALMODE&gt; PATH... :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*Changes permissions of a file. This works similar to the shell's chmod command( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*with a few exceptions.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*-R\s*modifies the files recursively. This is the only option currently( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*supported.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*&lt;MODE&gt;\s*Mode is the same as mode used for the shell's command. The only( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*letters recognized are 'rwxXt', e\.g\. \+t,a\+r,g-w,\+rwx,o=r\.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*&lt;OCTALMODE&gt;\s+Mode specifed in 3 or 4 digits. If 4 digits, the first may be 1 or( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*0 to turn the sticky bit on or off, respectively.( )*Unlike( |\t)*the( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*shell command, it is not possible to specify only part of the( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*mode, e\.g\. 754 is same as u=rwx,g=rx,o=r\.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*If none of 'augo' is specified, 'a' is assumed and unlike the shell command, no( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*umask is applied.( )*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for chown</description>
      <test-commands>
        <command>-help chown</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-chown \[-R\] \[OWNER\]\[:\[GROUP\]\] PATH... :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Changes owner and group of a file\. This is similar to the shell's chown command( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*with a few exceptions.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*-R( |\t)*modifies the files recursively. This is the only option currently( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*supported.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*If only the owner or group is specified, then only the owner or group is( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*modified. The owner and group names may only consist of digits, alphabet, and( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*any of .+?. The names are case sensitive.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*WARNING: Avoid using '.' to separate user name and group though Linux allows it.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*If user names have dots in them and you are using local file system, you might( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*see surprising results since the shell command 'chown' is used for local files.( )*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for chgrp</description>
      <test-commands>
        <command>-help chgrp</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-chgrp \[-R\] GROUP PATH... :( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*This is equivalent to -chown ... :GROUP ...( )*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for find</description>
      <test-commands>
        <command>-help find</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpAcrossOutputComparator</type>
          <expected-output>-find &lt;path&gt; \.\.\. &lt;expression&gt; \.\.\. :
  Finds all files that match the specified expression and
  applies selected actions to them\. If no &lt;path&gt; is specified
  then defaults to the current working directory\. If no
  expression is specified then defaults to -print\.
  
  The following primary expressions are recognised:
    -name pattern
    -iname pattern
      Evaluates as true if the basename of the file matches the
      pattern using standard file system globbing\.
      If -iname is used then the match is case insensitive\.
  
    -print
    -print0
      Always evaluates to true. Causes the current pathname to be
      written to standard output followed by a newline. If the -print0
      expression is used then an ASCII NULL character is appended rather
      than a newline.
  
  The following operators are recognised:
    expression -a expression
    expression -and expression
    expression expression
      Logical AND operator for joining two expressions\. Returns
      true if both child expressions return true\. Implied by the
      juxtaposition of two expressions and so does not need to be
      explicitly specified\. The second expression will not be
      applied if the first fails\.
</expected-output>	
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for help</description>
      <test-commands>
        <command>-help help</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-help \[cmd ...\] :( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*Displays help for given command or all commands if none is specified.( )*</expected-output>
        </comparator>
      </comparators>
    </test>

  </tests>
</configuration>
